*关于%rbp
程序在调用函数时，大多数情况下都不会执行：
	push %rbp
	movq %rsp, %rbp
%rbp很少作为栈帧的基址使用，大部分情况下都是作为普通寄存器使用
函数的栈帧基本都由%rsp一个寄存器控制
大多情况下，编译器在调用函数前都会计算出调用函数所需要的空间，只需利用：
	subq $xx, %rsp 为调用函数分配空间
	addq $xx, %rsp 清除分配的空间
不过某些时候，编译器无法计算出调用函数的所需空间时，%rbp用来储存基址，以便完成后续内存的释放以及%rsp的回指

*参数传递
%rdi,%rsi,%rdx,%rcx,%r8,%r9传递前六个参数，调用时直接调用寄存器
之后的参数储存在caller的栈帧，根据 %rsp+偏移值 调用

*递归调用
递归在本质上就是进程的自我调用，与普通的函数调用没有区别
不过个人还是感觉递归的整个过程实现有些神奇，尤其是对原寄存器值的保存与读取

每个递归过程都会产生资源消耗（栈消耗，控制转移/参数传递及返回造成的时间消耗...），一般能在一个进程中完成的操作尽量不要调用其他进程


*控制转移  数据传递  寄存器共享 
编译器在编译时会严格遵守指定的规则，以保证调用前后caller状态不会发生变化
